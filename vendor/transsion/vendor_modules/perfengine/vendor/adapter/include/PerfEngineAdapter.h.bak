// vendor/transsion/system_modules/perfengine/vendor/adapter/include/PerfEngineAdapter.h
// TODO delete
#ifndef PERFENGINE_ADAPTER_H
#define PERFENGINE_ADAPTER_H

#include <aidl/vendor/transsion/hardware/perfengine/BnPerfEngine.h>
#include <aidl/vendor/transsion/hardware/perfengine/IEventListener.h>
#include <android/binder_auto_utils.h>
#include <utils/Mutex.h>

#include <map>
#include <memory>
#include <vector>

namespace vendor {
namespace transsion {
namespace hardware {
namespace perfengine {

using ::aidl::vendor::transsion::hardware::perfengine::BnPerfEngine;
using ::aidl::vendor::transsion::hardware::perfengine::IEventListener;
using ::android::Mutex;

class PlatformAdapter;

/**
 * PerfEngine AIDL Service Implementation
 *
 * Responsibilities:
 *  - Implement IPerfEngine AIDL interface
 *  - Manage event-to-handle mapping
 *  - Delegate platform-specific calls to PlatformAdapter
 *  - Manage event listener registration and broadcasting
 *
 * Thread Safety:
 *  - AIDL methods are oneway (asynchronous) except registration methods
 *  - Internal state protected by mutex
 */
class PerfEngineAdapter : public BnPerfEngine {
public:
    PerfEngineAdapter();
    ~PerfEngineAdapter() override;

    // ==================== AIDL Event Notification Interface ====================

    ::ndk::ScopedAStatus notifyEventStart(int32_t eventId, int64_t timestamp, int32_t numParams,
                                          const std::vector<int32_t> &intParams,
                                          const std::optional<std::string> &extraStrings) override;

    ::ndk::ScopedAStatus notifyEventEnd(int32_t eventId, int64_t timestamp,
                                        const std::optional<std::string> &extraStrings) override;

    // ==================== AIDL Listener Registration Interface  ====================

    /**
     * Register an event listener
     *
     * Thread-safe: Can be called from any thread
     * Blocking call: Waits until registration completes
     */
    ::ndk::ScopedAStatus registerEventListener(
        const std::shared_ptr<IEventListener> &listener) override;

    /**
     * Unregister an event listener
     *
     * Thread-safe: Can be called from any thread
     * Blocking call: Waits until unregistration completes
     */
    ::ndk::ScopedAStatus unregisterEventListener(
        const std::shared_ptr<IEventListener> &listener) override;

private:
    // ==================== Event Handle Management ====================

    struct EventInfo {
        int32_t platformHandle;     // Platform-specific handle
        int64_t startTime;          // Event start timestamp
        std::string packageName;    // Associated package
    };

    std::map<int32_t, EventInfo> mActiveEvents;
    Mutex mEventLock;

    std::unique_ptr<PlatformAdapter> mPlatformAdapter;

    // ==================== Listener Management  ====================

    /**
     * Listener information including death recipient
     */
    struct ListenerInfo {
        std::shared_ptr<IEventListener> listener;
        ::ndk::ScopedAIBinder_DeathRecipient deathRecipient;

        ListenerInfo(std::shared_ptr<IEventListener> l, ::ndk::ScopedAIBinder_DeathRecipient dr)
            : listener(std::move(l)), deathRecipient(std::move(dr)) {}
    };

    std::vector<ListenerInfo> mListeners;
    Mutex mListenerLock;

    // ==================== Helper Methods ====================

    int32_t getDuration(const std::vector<int32_t> &intParams) const;
    void cleanupExpiredEvents();

    // Listener 管理辅助方法
    bool findListener(const std::shared_ptr<IEventListener> &listener);
    void removeListener(const std::shared_ptr<IEventListener> &listener);

    // 广播事件给所有订阅者
    void broadcastEventStart(int32_t eventId, int64_t timestamp, int32_t numParams,
                             const std::vector<int32_t> &intParams,
                             const std::optional<std::string> &extraStrings);

    void broadcastEventEnd(int32_t eventId, int64_t timestamp,
                           const std::optional<std::string> &extraStrings);

    // 死亡通知回调
    static void onListenerDied(void *cookie);
};

}    // namespace perfengine
}    // namespace hardware
}    // namespace transsion
}    // namespace vendor

#endif    // PERFENGINE_ADAPTER_H
